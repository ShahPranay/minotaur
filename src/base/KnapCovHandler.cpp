//
//     Minotaur -- It's only 1/2 bull
//
//     (C)opyright 2008 - 2024 The Minotaur Team.
//

/**
 * \file KnapCovHandler.h
 * \brief Declare the KnapCovHandler class for handling knapsack cover 
 * constraints. It generates the cuts whenever they are needed. 
 * \author Serdar Yildiz, Argonne National Laboratory
 */

#include <cmath>
#include <string>

#include "Constraint.h"
#include "CoverCutGenerator.h"
#include "CutManager.h"
#include "KnapCovHandler.h"
#include "Node.h"
#include "Option.h"
#include "Problem.h"

using namespace Minotaur;

typedef std::vector<ConstraintPtr>::const_iterator CCIter;
//const std::string KnapCovHandler::me_ = "KnapCovHandler: ";

// probably I will disable this function later.
KnapCovHandler::KnapCovHandler()
  : env_(EnvPtr()),
    minlp_(ProblemPtr()),
    stats_(0)
{
  // This is an abstract class, find a way to make this work such as Logger(log1).
  //logger_ = (LoggerPtr) new Logger();
  // env_ is a null pointer in this function hence setting a hardcoded value of intTol_.
  // intTol_ = env_->getOptions()->findDouble("int_tol")->getValue();
  intTol_ = 1e-6;
}

KnapCovHandler::KnapCovHandler(EnvPtr env, ProblemPtr minlp)
  : env_(env),
    minlp_(minlp),
    stats_(0)
{
  intTol_ = env_->getOptions()->findDouble("int_tol")->getValue();
  // Initialize logger.
  // Initialize statistics.
  stats_ = new KCStats();
  stats_->knaps = 0;
  stats_->cuts = 0;
  stats_->extended = 0;
  stats_->simple = 0;
  stats_->gns = 0;
  stats_->singlectwo = 0;
  stats_->time = 0.0;
  stats_->cutdel = 0;
}

KnapCovHandler::~KnapCovHandler()
{
  if(stats_) {
    //writeStats(logger_->MsgStream(LogInfo));
    delete stats_;
  }
  //env_.reset();
  //minlp_.reset();
}

bool KnapCovHandler::isFeasible(ConstSolutionPtr, RelaxationPtr, bool&, double&)
{
  // no need to check feasibility of knapsack constraints. It is automatically implied by
  // linear handler and integer handler.
  return true;
}

void KnapCovHandler::separate(ConstSolutionPtr sol, NodePtr, RelaxationPtr rel,
                              CutManager* cmanager, SolutionPoolPtr, ModVector&,
                              ModVector&, bool*, SeparationStatus* status)
{
  // Check integer feasibility of sol, must add cuts if it is not integral.
  numvars_ = minlp_->getNumVars();
  VariableType type;
  const double* x = sol->getPrimal();
  // Is the relaxation solution is integer feasible.
  bool isintfeas = true;
  // Iterators for variables.
  VariableConstIterator it;
  VariableConstIterator begin = rel->varsBegin();
  VariableConstIterator end = rel->varsEnd();
  // Temporary variable holder.
  ConstVariablePtr var;
  // Value of variable.
  double value;
  bool separated = false;
  UInt n_added = 0;

  // Check if integrality is satisfied for each integer variable.
  for(it = begin; it != end; ++it) {
    var = *it;
    type = var->getType();
    if(type == Binary || type == Integer) {
      value = x[var->getIndex()];
      if(fabs(value - floor(value + 0.5)) > intTol_) {
        isintfeas = false;
        break;
      }
    }
  }

  if(isintfeas == false) {
    // We do another check in CoverCutGneerator for integrality, may be we
    // should eliminate it and use the one above.
    // Generate cover cuts from current relaxation.
    CoverCutGeneratorPtr cover =
        (CoverCutGeneratorPtr) new CoverCutGenerator(rel, sol, env_);
    // Add cuts to the relaxation by using cut manager.
    CutVector violatedcuts = cover->getViolatedCutList();
    CutIterator itc;
    CutIterator beginc = violatedcuts.begin();
    CutIterator endc = violatedcuts.end();

    // Serdar I am not sure if we should add the constraints generated by
    // addCuts to the constraint vector of knapsack cover handler.
    // Currently CutMan2::addCuts does not add the cuts to the relaxation formulation.
    cmanager->addCuts(beginc, endc);
    cmanager->separate(rel, sol, &separated, &n_added);
    if(n_added > 0) {
      *status = SepaResolve;
    }

    // Update statistics by using return from cover cut generator.
    ConstCovCutGenStatsPtr covstats = cover->getStats();
    // Later put the code below to updateStats function.
    stats_->knaps += covstats->knaps;
    stats_->cuts += covstats->cuts;
    stats_->extended += covstats->extended;
    stats_->simple += covstats->simple;
    stats_->gns += covstats->gns;
    stats_->singlectwo += covstats->singlectwo;
  }
}

// void KnapCovHandler::updateStats(ConstCovCutGenStatsPtr covstats)
// {

// }

std::string KnapCovHandler::getName() const
{

  return "KnapCovHandler (Knapsack Cover)";
}

void KnapCovHandler::writeStats(std::ostream&) const { }

// Local Variables:
// mode: c++
// eval: (c-set-style "k&r")
// eval: (c-set-offset 'innamespace 0)
// eval: (setq c-basic-offset 2)
// eval: (setq fill-column 78)
// eval: (auto-fill-mode 1)
// eval: (setq column-number-mode 1)
// eval: (setq indent-tabs-mode nil)
// End:
